I"|,<h3 id="一-背景">一. 背景</h3>

<p>​	在开发中我们常会有这种需求：进入一个界面，请求一个接口，然后将接口的数据更新至UI上显示。在Android中，为了避免阻塞主线程，网络请求这种耗时操作需要放在子线程中，但在Android中，UI控件不是线程安全的，系统不允许在子线程中去更新UI。</p>

<p>​	因此现在的情况是，网络请求需要在子线程中，但是UI的更新需要放在主线程中，那么要如何在子线程获取接口数据后，通知主线更新UI呢？由此引出本文的主角 <strong>Handler</strong>。</p>

<h3 id="二-介绍">二. 介绍</h3>

<p>Handler主要用于线程之前的通信问题。</p>

<p>以背景中的问题为例子，界面中在子线程中请求网络数据，然后在子线程中更新UI。</p>

<p>首先在主线程中创建一个Handler，并且执行收到消息的操作</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="nc">Handler</span> <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Handler</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//收到消息后的操作</span>

            <span class="k">switch</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">what</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">case</span> <span class="nl">MSG_UPDATE_TV:</span>
                    <span class="n">mTv</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">obj</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">default</span><span class="o">:</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">};</span>
</code></pre></div></div>

<p>开启一个子线程模拟网络耗时操作，获取数据后通过Handler将消息发送至主线程</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 模拟网络请求</span>
    <span class="nc">SystemClock</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span>

    <span class="nc">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="nc">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
    <span class="n">message</span><span class="o">.</span><span class="na">what</span> <span class="o">=</span> <span class="no">MSG_UPDATE_TV</span><span class="o">;</span>
    <span class="n">message</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="s">"接口数据"</span><span class="o">;</span>
    <span class="n">mHandler</span><span class="o">.</span><span class="na">sendMessage</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}).</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<p>看到这里想必有同学心中就有个疑问了，为什么通过Handler可以将数据从子线程中发送至主线程中？</p>

<h3 id="三-源码分析">三. 源码分析</h3>

<p>要分析Handler的原理，就要介绍一下与它息息相关的几个类</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">类</th>
      <th style="text-align: center">职责</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Handler</td>
      <td style="text-align: center">用于发送与处理消息</td>
    </tr>
    <tr>
      <td style="text-align: center">Message</td>
      <td style="text-align: center">线程间通信消息的载体</td>
    </tr>
    <tr>
      <td style="text-align: center">MessageQueue</td>
      <td style="text-align: center">消息队列</td>
    </tr>
    <tr>
      <td style="text-align: center">Looper</td>
      <td style="text-align: center">用于不断的从队列中取消息，然后进行分发</td>
    </tr>
    <tr>
      <td style="text-align: center">ThreadLocal</td>
      <td style="text-align: center">存储线程作用域的局部变量</td>
    </tr>
  </tbody>
</table>

<h4 id="31-message">3.1 Message</h4>

<p>通过Handler实现线程间的数据传输，首先要依靠Message，顾名思义，也就是消息的载体。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="nc">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
<span class="n">message</span><span class="o">.</span><span class="na">what</span> <span class="o">=</span> <span class="no">MSG_UPDATE_TV</span><span class="o">;</span>
<span class="n">message</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="s">"接口数据"</span><span class="o">;</span>
</code></pre></div></div>

<p>Message用于携带线程间通信的一些数据</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Message</span> <span class="kd">implements</span> <span class="nc">Parcelable</span> <span class="o">{</span>
    
    <span class="c1">// 一般用于标识消息类型</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">what</span><span class="o">;</span>

    <span class="c1">// 传递int类型数据</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">arg1</span><span class="o">;</span>

    <span class="c1">// 传递int类型数据</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">arg2</span><span class="o">;</span>

    <span class="c1">// 传递普通对象，</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="n">obj</span><span class="o">;</span>

    <span class="c1">// Bundle数据</span>
    <span class="nc">Bundle</span> <span class="n">data</span><span class="o">;</span>

    <span class="c1">// 保存发送当前消息的Handler，也是处理该消息的Handler</span>
    <span class="nc">Handler</span> <span class="n">target</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>关于Message对象的创建，不建议使用new直接创建Message对象，系统存在Message的消息池，可实现消息对象的复用，避免大量创建消息对象带来的开销问题。</p>

<ul>
  <li>消息以链表的方式组成消息池</li>
  <li>消息池存在消息的最大缓存个数，最大消息个数为50个</li>
  <li>每次从消息池中获取消息时，若消息池中不存在消息，则新建消息，否则取出消息链表表头</li>
  <li>回收消息时，若当前消息池中消息缓存个数小于最大消息数，则将消息加入消息池中</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Message</span> <span class="kd">implements</span> <span class="nc">Parcelable</span> <span class="o">{</span>
    <span class="c1">//消息池以链表的形式存储</span>
    <span class="nc">Message</span> <span class="n">next</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">sPoolSync</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Message</span> <span class="n">sPool</span><span class="o">;</span>
    <span class="c1">//当前消息池内存在的消息数</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">sPoolSize</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="c1">//消息池中最大的消息数</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_POOL_SIZE</span> <span class="o">=</span> <span class="mi">50</span><span class="o">;</span>

    <span class="c1">//获取消息</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Message</span> <span class="nf">obtain</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">sPoolSync</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sPool</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//消息池中存在消息，取出消息头</span>
                <span class="nc">Message</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sPool</span><span class="o">;</span>
                <span class="n">sPool</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">m</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">m</span><span class="o">.</span><span class="na">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// clear in-use flag</span>
                <span class="n">sPoolSize</span><span class="o">--;</span>
                <span class="k">return</span> <span class="n">m</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Message</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 消息回收</span>
    <span class="kt">void</span> <span class="nf">recycleUnchecked</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span> 
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">sPoolSync</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sPoolSize</span> <span class="o">&lt;</span> <span class="no">MAX_POOL_SIZE</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//回收消息时,若当前消息池内数目小于最大数，则将消息放入消息池</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">sPool</span><span class="o">;</span>
                <span class="n">sPool</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
                <span class="n">sPoolSize</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="32-handler">3.2 Handler</h4>

<p>Handler的Api可以分成三类：发送消息、处理消息、移除消息</p>

<ul>
  <li>
    <p>发送消息</p>

    <p>发送的数据可以是Runnable或者其他的数据类型，无论发送什么数据，最终数据会被封装成Messages对象</p>

    <p>调用enqueueMessage将消息加入到消息队列中。</p>
  </li>
  <li>
    <p>处理消息</p>

    <p>消息最终由发送该Message的Handler进行处理(待会会分析)，消息的处理调用Handler的dispatchMessage方法，该方法中执行了处理消息的优先级，优先级从高到底为使用postXX发送的Runnable消息 &gt; 在Handler构造方法传入的Callback消息体 &gt; 使用sendXXMessage发送的消息</p>
  </li>
  <li>
    <p>移除消息</p>

    <p>通过removeXX来移除消息队列中未处理的Message，注意只能是还未进行处理的消息</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Handler</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="nf">Handler</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Callback</span> <span class="n">callback</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">async</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">FIND_POTENTIAL_LEAKS</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Handler</span><span class="o">&gt;</span> <span class="n">klass</span> <span class="o">=</span> <span class="n">getClass</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">klass</span><span class="o">.</span><span class="na">isAnonymousClass</span><span class="o">()</span> <span class="o">||</span> <span class="n">klass</span><span class="o">.</span><span class="na">isMemberClass</span><span class="o">()</span> <span class="o">||</span> <span class="n">klass</span><span class="o">.</span><span class="na">isLocalClass</span><span class="o">())</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">klass</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">()</span> <span class="o">&amp;</span> <span class="nc">Modifier</span><span class="o">.</span><span class="na">STATIC</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Log</span><span class="o">.</span><span class="na">w</span><span class="o">(</span><span class="no">TAG</span><span class="o">,</span> <span class="s">"The following Handler class should be static or leaks might occur: "</span> <span class="o">+</span>
                    <span class="n">klass</span><span class="o">.</span><span class="na">getCanonicalName</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">mLooper</span> <span class="o">=</span> <span class="nc">Looper</span><span class="o">.</span><span class="na">myLooper</span><span class="o">();</span>
        <span class="c1">// 若创建Handler时looper不存在，则会发生崩溃，这也是在子线程中不能直接创建Hander的原因</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mLooper</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span>
                <span class="s">"Can't create handler inside thread "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span>
                        <span class="o">+</span> <span class="s">" that has not called Looper.prepare()"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">mQueue</span> <span class="o">=</span> <span class="n">mLooper</span><span class="o">.</span><span class="na">mQueue</span><span class="o">;</span>
        <span class="n">mCallback</span> <span class="o">=</span> <span class="n">callback</span><span class="o">;</span>
        <span class="n">mAsynchronous</span> <span class="o">=</span> <span class="n">async</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">//被子类重写，接收消息时做 一些操作</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>   

    <span class="c1">//-----------发送消息</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">sendMessage</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">sendEmptyMessage</span><span class="o">(</span><span class="kt">int</span> <span class="n">what</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">sendEmptyMessageDelayed</span><span class="o">(</span><span class="kt">int</span> <span class="n">what</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delayMillis</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">sendEmptyMessageAtTime</span><span class="o">(</span><span class="kt">int</span> <span class="n">what</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">sendMessageDelayed</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delayMillis</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">sendMessageAtTime</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">sendMessageAtFrontOfQueue</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">post</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Runnable</span> <span class="n">r</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">postAtTime</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">postAtTime</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span> <span class="n">token</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">postDelayed</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delayMillis</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">postDelayed</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">what</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delayMillis</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">postDelayed</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span> <span class="n">token</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delayMillis</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">postAtFrontOfQueue</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Runnable</span> <span class="n">r</span><span class="o">)</span>
    <span class="c1">//-----------发送消息</span>
    
    <span class="c1">// 消息入队,上述所有发送消息的方法都会调用该方法</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">MessageQueue</span> <span class="n">queue</span><span class="o">,</span> <span class="nd">@NonNull</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">,</span>
            <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 设置消息的处理者</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">workSourceUid</span> <span class="o">=</span> <span class="nc">ThreadLocalWorkSource</span><span class="o">.</span><span class="na">getUid</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">mAsynchronous</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">setAsynchronous</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//将消息加入队列</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">enqueueMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">uptimeMillis</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/** 处理消息
     *  消息处理存在优先级，处理顺序 通过postXXX发送的消息&gt;直接在Handler构造方法传入的消息&gt;sendMessage发送的消息
     **/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dispatchMessage</span><span class="o">(</span><span class="nd">@NonNull</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">callback</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">handleCallback</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mCallback</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">mCallback</span><span class="o">.</span><span class="na">handleMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">handleMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 移除消息队列中what的待处理消息</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">removeMessages</span><span class="o">(</span><span class="kt">int</span> <span class="n">what</span><span class="o">)</span>
    <span class="c1">// 移除消息队列中所有what和object字段为object的待处理消息，obj为null,则移除所有what的待处理消息</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">removeMessages</span><span class="o">(</span><span class="kt">int</span> <span class="n">what</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
    <span class="c1">// 移除消息队列中obj为token的待处理消息，回调，若token为null，则移除所有所有消息和回调</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">removeCallbacksAndMessages</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Object</span> <span class="n">token</span><span class="o">)</span>

<span class="o">}</span> 
</code></pre></div></div>

<h4 id="33-messagequeue">3.3 MessageQueue</h4>

<p>消息队列中的Message其实是以链表的方式按消息执行的时间点从小到大存储的，表头的执行时间点最小，也就是最先处理</p>

<p>消息入队：enqueueMessage</p>

<ul>
  <li>若队列中不存在消息，或者新入队的消息执行时间点比表头小，则要创建消息表头</li>
  <li>存在表头的情况下，将消息插入到有序链表中</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Message must have a target."</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">isInUse</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">msg</span> <span class="o">+</span> <span class="s">" This message is already in use."</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mQuitting</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">IllegalStateException</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">+</span> <span class="s">" sending message to a Handler on a dead thread"</span><span class="o">);</span>
      <span class="nc">Log</span><span class="o">.</span><span class="na">w</span><span class="o">(</span><span class="no">TAG</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
      <span class="n">msg</span><span class="o">.</span><span class="na">recycle</span><span class="o">();</span>
      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 标记Message在使用中</span>
    <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
    <span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">=</span> <span class="n">when</span><span class="o">;</span>
    <span class="c1">// 消息队列是一个链表，这里使得p指向表头</span>
    <span class="nc">Message</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
    <span class="c1">// 是否需要唤醒</span>
    <span class="kt">boolean</span> <span class="n">needWake</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">when</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 消息队列中不存在消息的情况下或者消息执行时间点比表头小，创建表头</span>
      <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
      <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
      <span class="c1">// 唤醒阻塞</span>
      <span class="n">needWake</span> <span class="o">=</span> <span class="n">mBlocked</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="c1">// 如果是处于阻塞状态且消息为异步消息，消息头为屏障，则需要唤醒阻塞</span>
      <span class="n">needWake</span> <span class="o">=</span> <span class="n">mBlocked</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">();</span>
      <span class="nc">Message</span> <span class="n">prev</span><span class="o">;</span>
      <span class="c1">//链表是根据消息执行时间点从小到大排列的</span>
      <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 若异步消息未到达执行时间点，不需要唤醒</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">needWake</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">())</span> <span class="o">{</span>
          <span class="n">needWake</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
      <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// invariant: p == prev.next</span>
      <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 唤醒阻塞,nativePollOnce方法阻塞解除</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">needWake</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">nativeWake</span><span class="o">(</span><span class="n">mPtr</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>消息出队</p>

<ul>
  <li>若消息队列中没有消息或者消息未到达执行时间，则消息队列会处于阻塞状态</li>
  <li>若消息队列中存在可以执行的消息，则将消息从链表中移除，然后返回该消息</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 取出消息队列的消息</span>
<span class="nc">Message</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="kt">long</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">mPtr</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">int</span> <span class="n">pendingIdleHandlerCount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// -1 only during first iteration</span>
  <span class="kt">int</span> <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nextPollTimeoutMillis</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Binder</span><span class="o">.</span><span class="na">flushPendingCommands</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 当有消息入队或者消息执行时间达到，消息队列就会被唤醒，否则会一直阻塞</span>
    <span class="n">nativePollOnce</span><span class="o">(</span><span class="n">ptr</span><span class="o">,</span> <span class="n">nextPollTimeoutMillis</span><span class="o">);</span>

    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">();</span>
      <span class="nc">Message</span> <span class="n">prevMsg</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="nc">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 若消息头是一个消息屏障，找到消息队列中第一个异步消息</span>
        <span class="k">do</span> <span class="o">{</span>
          <span class="n">prevMsg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
          <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">());</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// 同步消息或者异步消息为达到消息的执行时间，设置下次唤醒的超时时间</span>
          <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">-</span> <span class="n">now</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="c1">// 消息已到达执行时间</span>
          <span class="n">mBlocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
          <span class="c1">// 把消息从消息队列中移除</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">prevMsg</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">prevMsg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
          <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
          <span class="o">}</span>
          <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
          <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
          <span class="c1">//返回消息</span>
          <span class="k">return</span> <span class="n">msg</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// 没有消息</span>
        <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">// Process the quit message now that all pending messages have been handled.</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">mQuitting</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 消息队列被停止，返回null</span>
        <span class="n">dispose</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span>


      <span class="k">if</span> <span class="o">(</span><span class="n">pendingIdleHandlerCount</span> <span class="o">&lt;</span> <span class="mi">0</span>
          <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">mMessages</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">mMessages</span><span class="o">.</span><span class="na">when</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">pendingIdleHandlerCount</span> <span class="o">=</span> <span class="n">mIdleHandlers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">pendingIdleHandlerCount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 没有可以立即处理的消息，继续阻塞</span>
        <span class="n">mBlocked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">continue</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="o">...</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<h4 id="34-threadlocal">3.4 ThreadLocal</h4>

<p>ThreadLocal简单的讲是一个用于存储线程作用域局部变量的类</p>

<p>这边用一个简单的例子来说明</p>

<ul>
  <li>创建一个ThreadLocal成员属性，在主线程使用set设置值，然后在子线程中通过get方法去取出值</li>
  <li>在子线程中通过set方法去设置值，然后在主线程中调用get方法去获取值</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">threadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">threadLocal</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">threadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"这边是主线程的数据"</span><span class="o">);</span>

  <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">threadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
      <span class="nc">Log</span><span class="o">.</span><span class="na">e</span><span class="o">(</span><span class="no">TAG</span><span class="o">,</span> <span class="s">"threadLocal "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">+</span> <span class="s">" msg = "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">);</span>
      <span class="n">threadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"子线程中的数据"</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}).</span><span class="na">start</span><span class="o">();</span>


  <span class="n">mHandler</span><span class="o">.</span><span class="na">post</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">threadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
      <span class="nc">Log</span><span class="o">.</span><span class="na">e</span><span class="o">(</span><span class="no">TAG</span><span class="o">,</span> <span class="s">"threadLocal "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">+</span> <span class="s">" msg = "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<p>执行结果</p>

<blockquote>
  <p>E/Handler==»: threadLocal Thread[Thread-3,5,main] msg = null</p>

  <p>E/Handler==»: threadLocal Thread[main,5,main] msg = 这边是主线程的数据</p>
</blockquote>

<p>可以看到在主线程通过set方法在ThreadLocal设置值后，在子线程中取出的值确是null；同样在子线程中通过set方法给ThreadLocal设置值，在主线程中取出，发现取出的值并没有发生改变，这就是ThreadLocal变量的线程作用域，也就是说存储的变量只在当前线程内有效，该变量对其他线程来说是不可见的。</p>

<p>我们来分析一下它的实现原理，首先通过set方法来设置变量</p>

<ul>
  <li>存在一个线程与变量的map，存储变量时，首先根据线程获取对应的ThreadLocalMap，若存在则更新map的值</li>
  <li>若ThreadLocalMap不存在，则创建对应ThreadLocalMap，把值放入Map中</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
  <span class="nc">ThreadLocalMap</span> <span class="n">map</span> <span class="o">=</span> <span class="n">getMap</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">map</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
    <span class="n">map</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
  <span class="k">else</span>
    <span class="nf">createMap</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>我们来看看getMap和createMap这两个方法，不难发现两个方法其实都是去操作了Thread的一个成员属性，也就是说无论在哪个线程中去调用ThreadLocalMap的set方法，最终还是将值存储在了对应线程的ThreadMap中，不同的线程有着不同的ThreadLocalMap实例。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ThreadLocalMap</span> <span class="nf">getMap</span><span class="o">(</span><span class="nc">Thread</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="na">threadLocals</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">createMap</span><span class="o">(</span><span class="nc">Thread</span> <span class="n">t</span><span class="o">,</span> <span class="no">T</span> <span class="n">firstValue</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">t</span><span class="o">.</span><span class="na">threadLocals</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocalMap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">firstValue</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>同理，看下ThreadLocal的get方法</p>

<ul>
  <li>拿到调用当前方法的线程信息</li>
  <li>从当前线程的成员属性ThreadLocalMap取出属性值，不存在则在Map中插入默认值，并且返回</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
  <span class="nc">ThreadLocalMap</span> <span class="n">map</span> <span class="o">=</span> <span class="n">getMap</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">map</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ThreadLocalMap</span><span class="o">.</span><span class="na">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getEntry</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
      <span class="no">T</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span><span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="nf">setInitialValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="36-looper">3.6 Looper</h4>

<p>Looper的职责是不断的从消息队列中取出消息，然后将消息进行分发。</p>

<ul>
  <li>Looper在创建时会自动关联消息队列以及Looper对应的线程</li>
  <li>loop方法中是一个死循环，会不断的从消息队列中取消息，有消息则将消息分发，最终消息的处理还是交给发送该消息的Handler</li>
  <li>若消息队列中不存在可以立刻执行的消息，则会一直处于阻塞状态(next方法)，直到有可执行的消息</li>
  <li>Looper有两种停止方式：强制停止与安全停止。强制停止会移除消息队列中所有的消息，而安全的停止只会移除消息队列中未到执行时间的消息，达到执行时间或者正在执行的消息还是会继续处理，直到队列中不存在消息，此时停止消息队列，再停止Looper</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Looper</span> <span class="o">{</span>
    <span class="c1">// 线程-Looper Map</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Looper</span><span class="o">&gt;</span> <span class="n">sThreadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Looper</span><span class="o">&gt;();</span>

    <span class="c1">// 主线程对应的Looper</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Looper</span> <span class="n">sMainLooper</span><span class="o">;</span> 

    <span class="kd">final</span> <span class="nc">MessageQueue</span> <span class="n">mQueue</span><span class="o">;</span>

    <span class="c1">// 创建Looper的线程</span>
    <span class="kd">final</span> <span class="nc">Thread</span> <span class="n">mThread</span><span class="o">;</span>
    
    <span class="c1">// quitAllowed表示是否允许停止</span>
    <span class="kd">private</span> <span class="nf">Looper</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 创建Looper时会创建消息队列，并且与创建Looper的线程关联</span>
        <span class="n">mQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MessageQueue</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">);</span>
        <span class="n">mThread</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 创建当前线程的Looper</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">()</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Only one Looper may be created per thread"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">sThreadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">new</span> <span class="nc">Looper</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// 创建主线程对应的Looper</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepareMainLooper</span><span class="o">()</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">Looper</span> <span class="n">me</span> <span class="o">=</span> <span class="n">myLooper</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">me</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"No Looper; Looper.prepare() wasn't called on this thread."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">final</span> <span class="nc">MessageQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="na">mQueue</span><span class="o">;</span>
        <span class="o">...</span>

        <span class="c1">// 死循环</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="c1">// 若消息队列中没有可执行的消息，则会处于阻塞状态</span>
            <span class="nc">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">next</span><span class="o">();</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 消息队列停止，msg返回null</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="o">...</span> 

            <span class="kt">long</span> <span class="n">origWorkSource</span> <span class="o">=</span> <span class="nc">ThreadLocalWorkSource</span><span class="o">.</span><span class="na">setUid</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">workSourceUid</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">//将取出的下次进行分发，target为发送该消息的Handler</span>
                <span class="n">msg</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">dispatchMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">observer</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">observer</span><span class="o">.</span><span class="na">messageDispatched</span><span class="o">(</span><span class="n">token</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">dispatchEnd</span> <span class="o">=</span> <span class="n">needEndTime</span> <span class="o">?</span> <span class="nc">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">observer</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">observer</span><span class="o">.</span><span class="na">dispatchingThrewException</span><span class="o">(</span><span class="n">token</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span> <span class="n">exception</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">throw</span> <span class="n">exception</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="nc">ThreadLocalWorkSource</span><span class="o">.</span><span class="na">restore</span><span class="o">(</span><span class="n">origWorkSource</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">traceTag</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Trace</span><span class="o">.</span><span class="na">traceEnd</span><span class="o">(</span><span class="n">traceTag</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
            <span class="o">...</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">recycleUnchecked</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//直接停止，会移除队列中所有的消息，包括正在使用的消息</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">quit</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mQueue</span><span class="o">.</span><span class="na">quit</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 安全地停止，只未到执行时间点的消息，而达到执行时间点的消息或者正在执行的消息还会执行完</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">quitSafely</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mQueue</span><span class="o">.</span><span class="na">quit</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这边看下Looper的停止，可以看到，停止Looper，最终还是要先停止消息队列</p>

<p>MessageQueue.java</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">quit</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">safe</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 若消息队列不能被停止，此时会抛出异常</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">mQuitAllowed</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Main thread not allowed to quit."</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mQuitting</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 若已设置停止标志位，说明正在停止或者已经停止，直接返回</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">mQuitting</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">safe</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 安全的停止</span>
      <span class="n">removeAllFutureMessagesLocked</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="c1">// 强制停止</span>
      <span class="n">removeAllMessagesLocked</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// We can assume mPtr != 0 because mQuitting was previously false.</span>
    <span class="n">nativeWake</span><span class="o">(</span><span class="n">mPtr</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>首先看安全的停止</p>

<ul>
  <li>若表头执行时间点未到，整个消息队列中的消息都回收</li>
  <li>消息队列中正在执行的消息或者已经到达执行时间点的消息还会继续执行</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">removeAllFutureMessagesLocked</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">();</span>
  <span class="c1">// 一个按执行时间点从小到大排列的链表</span>
  <span class="nc">Message</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">when</span> <span class="o">&gt;</span> <span class="n">now</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 表头的执行时间还未到，说明整个链表都是执行时间未到的消息，全部取消</span>
      <span class="n">removeAllMessagesLocked</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="c1">// 表头为立刻执行的消息</span>
      <span class="nc">Message</span> <span class="n">n</span><span class="o">;</span>
      <span class="c1">// 找到第一个未到执行时间点的消息</span>
      <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">when</span> <span class="o">&gt;</span> <span class="n">now</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="c1">//将所有未到执行时间点的消息全部移除回收</span>
      <span class="k">do</span> <span class="o">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">recycleUnchecked</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从上可知，在安全停止时，消息队列中所有的消息还为达到执行时间，则会调用强制取消的方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">removeAllMessagesLocked</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">Message</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
  <span class="c1">//遍历整个链表，回收所有的消息</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Message</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">p</span><span class="o">.</span><span class="na">recycleUnchecked</span><span class="o">();</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="n">mMessages</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="37-总结">3.7 总结</h4>

<p><img src="http://qagey3wv5.bkt.clouddn.com//handler.png" alt="handler" /></p>

<ul>
  <li>Handler将消息发送至消息队列，消息在消息队列中按照执行的时间点从小到大且以链表的方式排列</li>
  <li>Looper用于从消息队列中取出消息和对消息进行分发，loop是一个死循环，它会不断的从消息队列中取出消息，若存在可执行的消息，则将消息分发至Handler进行处理</li>
  <li>若消息队列中不存在可以立即执行的消息，则Looper会处于阻塞状态，直到消息队列中存在可立即执行的消息</li>
</ul>

<h3 id="四-常见问题">四. 常见问题</h3>

<h4 id="41-子线程是否能创建handler">4.1 子线程是否能创建Handler</h4>

<p>可以，但是需要为子线程创建Looper，若子线程中不存在对应的Looper，则会抛出异常</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">Handler</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Callback</span> <span class="n">callback</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">async</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">mLooper</span> <span class="o">=</span> <span class="nc">Looper</span><span class="o">.</span><span class="na">myLooper</span><span class="o">();</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">mLooper</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span>
      <span class="s">"Can't create handler inside thread "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span>
      <span class="o">+</span> <span class="s">" that has not called Looper.prepare()"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>此时有人可能有疑问，为什么在主线程创建Handler不需要我们手动创建Looper。其实这个创建Looper的过程Android的Framework已经帮我们实现了。</p>

<p>ActivityThread.java</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 	<span class="o">...</span>
  
  <span class="c1">// 为主线程创建Looper</span>
  <span class="nc">Looper</span><span class="o">.</span><span class="na">prepareMainLooper</span><span class="o">();</span>
  
  <span class="nc">ActivityThread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ActivityThread</span><span class="o">();</span>
  <span class="n">thread</span><span class="o">.</span><span class="na">attach</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">startSeq</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">sMainThreadHandler</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sMainThreadHandler</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="na">getHandler</span><span class="o">();</span>
  <span class="o">}</span>
 	<span class="c1">// 启动looper</span>
  <span class="nc">Looper</span><span class="o">.</span><span class="na">loop</span><span class="o">();</span>

  <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Main thread loop unexpectedly exited"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="42-在同一线程中-androidhandler-和-androidmessaegqueue-的数量对应关系">4.2 在同一线程中 android.Handler 和 android.MessaegQueue 的数量对应关系</h4>

<p>一个线程只存在一个MessageQueue和Looper，但可以有多个Handler，所以是多对一。</p>

<p>例如Activity的onCreate、onResume()等方法都是通过底层发送的消息而回调的</p>

<p>参考资料：</p>

<ul>
  <li>
    <p>《Android开发艺术探索》</p>
  </li>
  <li>
    <p><a href="https://blog.csdn.net/start_mao/article/details/98963744">Handler机制——同步屏障</a></p>
  </li>
</ul>

:ET