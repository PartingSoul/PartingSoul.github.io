I"?)<h3 id="一--概述">一.  概述</h3>

<p>​		前面我们介绍了Messenger的基本用法，相对于AIDL而言，Messenger的用法更简单，但是Messenger不具有并发处理任务的能力，这是两者主要的区别。但是Messenger同样是基于AIDL实现的，这边我们来讲讲它的实现原理。</p>

<h3 id="二-源码分析">二. 源码分析</h3>

<h4 id="21-服务端">2.1 服务端</h4>

<p>​		在使用Messenger时，我们会在服务端的Service中创建一个Messenger，通过Messenger获得一个IBinder对象，在onBind方法中返回。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessengerService</span> <span class="kd">extends</span> <span class="nc">Service</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Messenger</span> <span class="n">mMessenger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Messenger</span><span class="o">(</span><span class="k">new</span> <span class="no">H</span><span class="o">());</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IBinder</span> <span class="nf">onBind</span><span class="o">(</span><span class="nc">Intent</span> <span class="n">intent</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">mMessenger</span><span class="o">.</span><span class="na">getBinder</span><span class="o">();</span>
    <span class="o">}</span>
	<span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从创建Messenger开始，参数是一个Handler</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Messenger</span> <span class="kd">implements</span> <span class="nc">Parcelable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">IMessenger</span> <span class="n">mTarget</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Messenger</span><span class="o">(</span><span class="nc">Handler</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mTarget</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">getIMessenger</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>​		可以看到，在构造方法中通过去获取IMessenger对象，我们来看看Handler代码，可以看到getIMessenger方法中若Messenger不存在，则创建一个Messenger实现类MessengerImpl对象，然后返回。</p>

<p>Handler.java</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">IMessenger</span> <span class="nf">getIMessenger</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">synchronized</span> <span class="o">(</span><span class="n">mQueue</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mMessenger</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">mMessenger</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">mMessenger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MessengerImpl</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">mMessenger</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>​		我们来看下MessengerImpl类，原来IMessenger是一个aidl接口，该接口中定义了一个send方法，供客户端调用。send方法是服务端的具体逻辑实现，可以看到这里将客户端发送过来的消息交给了Handler，这也就是Messenger只能够串行处理客户端请求的原因。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">MessengerImpl</span> <span class="kd">extends</span> <span class="nc">IMessenger</span><span class="o">.</span><span class="na">Stub</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">send</span><span class="o">(</span><span class="nc">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">msg</span><span class="o">.</span><span class="na">sendingUid</span> <span class="o">=</span> <span class="nc">Binder</span><span class="o">.</span><span class="na">getCallingUid</span><span class="o">();</span>
    <span class="nc">Handler</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">sendMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>IMessenger.aidl定义</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">android.os</span><span class="o">;</span>

<span class="cm">/** @hide */</span>
<span class="n">oneway</span> <span class="kd">interface</span> <span class="nc">IMessenger</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">send</span><span class="o">(</span><span class="n">in</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="22-客户端">2.2 客户端</h4>

<p>​	在客户端，服务端绑定成功后需要将服务端返回的IBinder对象封装成Messenger对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onServiceConnected</span><span class="o">(</span><span class="nc">ComponentName</span> <span class="n">name</span><span class="o">,</span> <span class="nc">IBinder</span> <span class="n">service</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="s">"service connected"</span><span class="o">);</span>
    <span class="n">isBound</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="n">mServiceMessenger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Messenger</span><span class="o">(</span><span class="n">service</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>我们来看这个形参为IBinder的构造方法，可以看到在构造方法中，通过生成的aidl类IMessenger.Stub把IBinder对象转化成了IMessenger对象，供客户端调用。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Messenger</span> <span class="kd">implements</span> <span class="nc">Parcelable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">IMessenger</span> <span class="n">mTarget</span><span class="o">;</span>
 		
  	<span class="kd">public</span> <span class="nf">Messenger</span><span class="o">(</span><span class="nc">IBinder</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mTarget</span> <span class="o">=</span> <span class="nc">IMessenger</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="o">}</span>
  	<span class="o">....</span>
<span class="o">}</span>
</code></pre></div></div>

<p>客户端通过封装的Messenger发送消息</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="nc">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
<span class="n">message</span><span class="o">.</span><span class="na">what</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="n">mServiceMessenger</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</code></pre></div></div>

<p>我们来看下Messenger的send方法，可以看到最终还是调用了IMessenger的send方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">send</span><span class="o">(</span><span class="nc">Message</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemoteException</span> <span class="o">{</span>
    <span class="n">mTarget</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>关于AIDL部分这边不再做分析，见<a href="https://partingsoul.github.io/2020/01/13/AIDL%E8%BF%9B%E9%98%B6/">AIDL进阶</a></p>

<h4 id="23-小结">2.3 小结</h4>

<p><img src="http://qagey3wv5.bkt.clouddn.com/Messenger.png" alt="Messenger" /></p>

<ul>
  <li>Messenger内部实现还是通过AIDL，只是Messenger封装了AIDL</li>
  <li>Messenger的AIDL方法中定义了一个用于客户端向服务端发送消息的send方法</li>
  <li>服务端send方法的具体实现是直接把客户端发送过来的消息发送给了Handler，交给Handler处理</li>
</ul>
:ET