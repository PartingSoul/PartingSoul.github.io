I"C<h3 id="1-setresult调用时机">1. setResult调用时机</h3>

<p><img src="http://qagey3wv5.bkt.clouddn.com/image-121.png" alt="image" /></p>

<p>场景： CommonActivity使用startForResult启动ActivityOne</p>

<p>现象：可以看到CommonActivity的onActivityForResult方法是在ActivityOne的onPause方法执行后调用的</p>

<p>调用时机：经过测试ActivityOne中调用setResult的时机应在finish方法被调用之前。</p>

<h3 id="2-onsaveinstancestate与onrestoreinstancestate">2. onSaveInstanceState与onRestoreInstanceState</h3>

<ul>
  <li>onSaveInstanceState用于保存Activity的瞬态，例如UI的状态，以便Activity异常退出时能够通过onRestoreInstanceState恢复一些之前的状态</li>
  <li>onSaveInstanceState不是每次会调用，只有当前Activity可会会被异常终止，但是它还有可能重新回到前台的情况下，才会被调用(例如：按Home键或者在当前Activity启动一个新的Activity，当前Activity也会调用该方法、配置文件发生变化、手机锁屏)；在用户主动退出的情况(例如调用finish或者按返回键)不会调用该方法</li>
  <li>onRestoreInstanceState在Activity异常退出并且重建Activity时被调用，用于恢复之前保存的状态，该方法被调用的另一前提是onSaveInstanceState存在保存的状态，即Bundle不为null</li>
</ul>

<h3 id="3-activity的启动模式">3. Activity的启动模式</h3>

<p>Activity有四种启动模式：</p>

<ul>
  <li>Standard : 标准启动模式，使用了该启动模式的Activity，每次启动都会重新创建一个Activity，压入任务栈中</li>
  <li>SingleTop: 栈顶复用模式，使用了该启动模式的Activity，启动Activity时，若当前任务栈栈顶已经是该Activity，则不会重新创建Activity，只是会调用栈顶Activity的onNewIntent方法；若栈顶不是该Activity的实例，表现方式与Standard模式相同</li>
  <li>SingleTask: 栈内复用模式，使用了该模式的Activity，启动时，会先查找当前Actvity的任务栈是否存在，若不存在，则创建任务栈，并启动Activity并将Activity压入到该任务栈中；若任务栈已经存在，则去任务栈中寻找是否存在该Activity的实例，如果不存在，创建Activity，压入任务栈；若任务栈中存在该Activity，将该Activity上方的所有Activity出栈，并调用该Activity的onNewIntent方法</li>
  <li>SingleInstance：全局单例模式，使用此模式的Activity会单独位于一个任务栈中，后续启动的Activity不会再创建新的任务栈，即使指定了TaskAffinity也不会有效果</li>
</ul>

<p>在SingleTask中我们提到了任务栈的创建，默认情况下所有Activity的任务栈为应用的包名，但是我们可以为每个Activity指定任务栈的名字，该属性为TaskAffinity，只有和SingleTask模式结合起来才会起作用。</p>

<h4 id="31-startactivity和startactivityforresult对启动模式的影响">3.1 startActivity和startActivityForResult对启动模式的影响</h4>

<ul>
  <li>使用startActivityForResult方式启动Activity，无论被启动的Activity是什么启动模式，都会和启动方在一个任务栈中</li>
  <li>若使用startActivity方式启动Activity，被启动的Activity为singleTask且指定了任务栈或者启动模式为singleInstance，则被启动的Activity会进入自己对应的任务栈中</li>
</ul>

<p>先用例子看看第一点：存在三个Activity，MainActivity、ActivityA、ActivityB。ActivityA的启动模式为singleTask，在MainActivity中使用startActivityForResult方式启动ActivityA，然后在ActivityA中启动ActivityB</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;activity</span> <span class="na">android:name=</span><span class="s">".MainActivity"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;intent-filter&gt;</span>
    <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.intent.action.MAIN"</span> <span class="nt">/&gt;</span>

    <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.LAUNCHER"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/intent-filter&gt;</span>
<span class="nt">&lt;/activity&gt;</span>
<span class="nt">&lt;activity</span>
     <span class="na">android:taskAffinity=</span><span class="s">"com.A"</span>
     <span class="na">android:name=</span><span class="s">".ActivityA"</span>
     <span class="na">android:launchMode=</span><span class="s">"singleTask"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;activity</span>
      <span class="na">android:name=</span><span class="s">".ActivityB"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p>打印任务栈</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adb shell dumpsys activity activities
</code></pre></div></div>

<p>任务栈结构图</p>

<p><img src="http://qagey3wv5.bkt.clouddn.com//image (2).png" alt="imgage2" /></p>

<p>可以看到虽然ActivityA启动模式为singleTask且指定了任务栈，但是还是和启动它的Activity放在了一个任务栈中</p>

<p>若MainActivity采用startActivity的方式启动ActvityA，此时ActivityA会位于自己的任务栈中</p>

<p><img src="http://qagey3wv5.bkt.clouddn.com//image (3).png" alt="iamge3" /></p>

<h4 id="32-创建新的任务栈按home键切换至lancher再点击应用图标">3.2 创建新的任务栈按Home键切换至Lancher再点击应用图标</h4>

<p>这里的启动方式都为startActivity。</p>

<p>还是上述三个Activity，第一次打来应用，MainActivity会启动ActivityA，ActivityA的启动模式为singleTask，ActivityA中启动ActivityB，此时的任务栈内容</p>

<p><img src="http://qagey3wv5.bkt.clouddn.com//image (4).png" alt="image4" /></p>

<p>此时按住Home键返回至Lancher界面，然后点击该应用应用图标，会发现当前打开的界面是MainActivity,而不是ActivityB，也就是打开的是应用默认任务栈的栈顶Activity。</p>

<p>若ActivityA的启动模式改为singleInstance，打开的还是应用默认任务栈的栈顶Activity,只不过此时栈顶Activity为ActivityB，ActivityA位于单独的一个栈中。</p>

<h4 id="33-启动其他应用的activity时任务栈状态">3.3 启动其他应用的Activity时任务栈状态</h4>

<p>这边同样讨论使用startActivity的启动方式</p>

<ul>
  <li>若其他应用提供的Activity的启动模式为singleTask或者singleInstance，则启动的Activity会放入其自己的任务栈中</li>
  <li>
    <p>若启动Activity的启动模式为standard或者singleTop，则启动的Activity会放入启动方的任务栈中</p>
  </li>
  <li>当被启动的Activity的<strong>allowTaskReparenting</strong>属性设置为true，且启动模式为singleTop或者standard时，启动时被启动的Activity会进入启动方的任务栈，但是在Launcher中点击被启动Activity对应的应用，打开的界面不是应用主界面，而且刚才在其他应用启动的Activity，且此时Activity已经从启动方任务栈移动到了本应用任务栈中。</li>
</ul>

<h4 id="34-特殊情况">3.4 特殊情况</h4>

<p>当应用入口Activity的启动模式为singleTask，由它启动ActivityA，ActivityA启动ActivityB，ActivityA和ActivityB的启动模式为standard，此时若点击Home返回桌面，再点击应用图标，此时界面显示的是MainActivity，相当于点击应用图标，系统重新启动了MainActivity，表现形式为singleTask的特性。</p>

:ET